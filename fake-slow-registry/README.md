Golang code taken from https://gist.github.com/aruiz14/39c37a3d8b3f768f2c169c2e774b139b

Directory structure and contents, other than the Go code, mostly generated by Gemini through the following prompt:
```
Given the following Golang files: https://gist.github.com/aruiz14/39c37a3d8b3f768f2c169c2e774b139b
Prepare a directory structure allowing the corresponding code, implementing an HTTP server, to be deployed in a Kubernetes cluster. The directory structure should include:
- a Dockerfile for compiling those Golang files into a binary, and running that binary
- a Kubernetes Deployment manifest referencing the Docker image built in the previous step, for instance as `aruiz14/fake-slow-registry:test`
- a Kubernetes Service manifest exposing the Deployment within the cluster, on port 4242.
```

How to run the server in a Kubernetes cluster:
1. Build the image: `docker build -t aruiz14/fake-slow-registry:test .`
2. Import the image into the cluster, e.g. for a cluster named `upstream`: `k3d image import -m direct -c upstream aruiz14/fake-slow-registry:test`
    * Alternatively, push the image to a temporary registry, e.g. ttl.sh
3. Apply the manifests, to create the deployment and service: `kubectl apply -f manifests`
4. Check that the server works, for instance by querying it from inside the cluster:
   - Create a test client pod: `kubectl run test-curl --image registry.suse.com/bci/bci-base:15.7 -- sleep 3600`
   - Shell into the pod (`kubectl exec` or using k9s's `shell` shortcut against the pod), and run:
    `curl <service_cluster_ip>:4242/index.yaml`, where `<service_cluster_ip>` is the cluster IP of the
`fake-slow-registry-service` service.
   - In this case, the server should take ~10s to serve a registry index; this can be adjusted in the Dockerfile,
after which the image must be rebuilt, imported into the cluster (if k3d) or pushed again, and the deployment must be
re-created (see steps 1-3 above).
